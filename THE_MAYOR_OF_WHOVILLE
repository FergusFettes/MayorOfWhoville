I am the mayor of Whoville! May all tremble before me!

What do you require of me, good peasants of this town?
import os
import asyncio
import logging
import time
import random as ra
import websockets

FORMAT = "%(levelname)s@%(name)s(%(asctime)s) -- \"%(message)s\""
logging.basicConfig(level=logging.INFO, format=FORMAT)

from township import Town

PATH = os.path.dirname(os.path.realpath(__file__)) + "/THE_MAYOR_OF_WHOVILLE"

class ServerHelper:
    TOWNSHIPS = {
    "Whoville":[],
    "Pooville":[],
    "Trueville":[],
    "Flooville":[],
    "Shoeville":[],
    "Blueville":[],
    "Screwville":[],
    "Whatatodoville":[],
    "Grueville":[],
    "Jewville":[],
    "Stewville":[],
    "Brewville":[],
    "Gooville":[],
    }
    FULLSTRING = "No more towns left"
    ACTIVE_TOWNS = []
    TOWNSHIP_HANDSAKE = "I'm just a township"
    MAYOR_REQUEST = "We need to speak to the Mayor!"
    TRANSMISSION_COMPLETE = "The mayor is in town!"
    CHUNK = 1024
    MAYOR_PRESENT = True
    MAYOR_OUT = "Sorry, the mayor is out on important business"
    def assign_connection_to_town(self, websocket):
        possible_towns = []
        for town in self.TOWNSHIPS:
            if not self.TOWNSHIPS[town]:
                possible_towns.append(town)
        if not len(possible_towns):
            return self.FULLSTRING
        choice = possible_towns[ra.randint(0, len(possible_towns) - 1)]
        self.TOWNSHIPS[choice] = websocket
        self.ACTIVE_TOWNS.append(choice)
        return choice

    def remove_connection_from_town(self, websocket):
        for town in self.TOWNSHIPS:
            if self.TOWNSHIPS[town] is websocket:
                self.TOWNSHIPS[town] = []
                self.ACTIVE_TOWNS.remove(town)

    def choose_random_active_town(self):
        choice = ra.randint(0, len(self.ACTIVE_TOWNS) - 1)
        return self.TOWNSHIPS[self.ACTIVE_TOWNS[choice]]

class Server:
    def __init__(self):
        self.helper = ServerHelper()

    def create_websocket_handler(self, address):
        return websockets.serve(self.async_init, "localhost", address)

    async def async_init(self, websocket, path):
        handshake = await websocket.recv()
        logging.info("Handshake: {}".format(handshake))
        if handshake == self.helper.TOWNSHIP_HANDSAKE:
            await self.main_township_loop(websocket)
        elif handshake == self.helper.MAYOR_REQUEST:
            await self.process_mayor_request(websocket, self.helper.CHUNK)
        logging.info("Closing connection")

    async def process_mayor_request(self, websocket, chunk):
        if self.helper.MAYOR_PRESENT:
            logging.info("Prepairing to send mayor")
            self.helper.MAYOR_PRESENT = False

            parent_websocket_name = await websocket.recv()
            parent_websocket = self.helper.TOWNSHIPS[parent_websocket_name]

            await self.send_mayor(websocket, chunk)

            await parent_websocket.send(self.helper.TRANSMISSION_COMPLETE)
            logging.info("Mayor sent")
        else:
            logging.info("Mayor not about, sending shutdown")
            parent_websocket_name = await websocket.recv()
            parent_websocket = self.helper.TOWNSHIPS[parent_websocket_name]
            await parent_websocket.send(self.helper.MAYOR_OUT)

    async def send_mayor(self, websocket, chunk):
        with open(PATH, 'rb') as fi:
            while True:
                byte_chunk = fi.read(chunk)
                await websocket.send(byte_chunk)
                if not byte_chunk:
                    break
        os.system("rm {}".format(PATH))

    async def main_township_loop(self, websocket):
        name = self.helper.assign_connection_to_town(websocket)
        if name == self.helper.FULLSTRING:
            raise
        await self.assign_name(websocket, name)
        try:
            await self.async_gather_functions(websocket)
        finally:
            self.helper.remove_connection_from_town(websocket)
            logging.info("{} has disconnected!".format(name))

    async def assign_name(self, websocket, name):
        await websocket.send(name)
        logging.info("{} has been assigned!".format(name))

    async def send_message(self, websocket):
        while True:
            await asyncio.sleep(ra.random() * 3)
            await websocket.send("toasties")

    async def process_message(self, websocket):
        while True:
            message = await websocket.recv()
            logging.info("Server got a message: {}".format(message))

    async def async_gather_functions(self, websocket):
        tasks = []
        tasks.append(self.process_message(websocket))
        tasks.append(self.send_message(websocket))
        await asyncio.gather(*tasks)

if __name__=="__main__":
    address = 8002
    srv = Server()
    asyncio.get_event_loop().run_until_complete(srv.create_websocket_handler(address))
    asyncio.get_event_loop().run_forever()
import os
import asyncio
import logging
import time
import random as ra
import websockets

FORMAT = "%(levelname)s@%(name)s(%(asctime)s) -- \"%(message)s\""
logging.basicConfig(level=logging.INFO, format=FORMAT)

PATH = os.path.dirname(os.path.realpath(__file__)) + "/THE_MAYOR_OF_WHOVILLE_IN_TOWN"

class Town:
    MAYOR_REQUEST = "We need to speak to the Mayor!"
    TRANSMISSION_COMPLETE = "The mayor is in town!"
    TOWNSHIP_HANDSAKE = "I'm just a township"
    MAYOR_OUT = "Sorry, the mayor is out on important business"
    def __init__(self, address):
        self.uri = "ws://localhost:{}".format(address)
        self.name = ''

    async def initiate(self):
        async with websockets.connect(self.uri) as websocket:
            await websocket.send(self.TOWNSHIP_HANDSAKE)
            self.name = await websocket.recv()
            logging.info("I have a name! My name is {}".format(self.name))
            while True:
                func = self.choose_my_function()
                await func(websocket)
                logging.info("Process complete, should be starting a new one?")

    async def process_mayoral_transmission(self, websocket):
        reciever = asyncio.ensure_future(self.request_mayor())
        ender = asyncio.ensure_future(self.wait_for_transmission_end(websocket))
        done, pending = await asyncio.wait(
            [reciever, ender],
            return_when=asyncio.FIRST_COMPLETED
        )
        for task in pending:
            task.cancel()

    async def wait_for_transmission_end(self, websocket):
        logging.info("Waiting for response from CMA")
        while True:
            message = await websocket.recv()
            if message == self.TRANSMISSION_COMPLETE:
                logging.info("Transmission successful, waiting completion")
                await asyncio.sleep(2)
            elif message == self.MAYOR_OUT:
                logging.info("Mayor is out on business! Shutting down")
                break
            else:
                logging.info("Processor got a message, unrelated to its currently deeply important duties and promptly disregarded it")

    async def request_mayor(self):
        async with websockets.connect(self.uri) as inner_websocket:
            try:
                await inner_websocket.send(self.MAYOR_REQUEST)
                await inner_websocket.send(self.name)
                await receive_mayor(inner_websocket)
            except:
                logging.info("Reciever was shutdown")
        logging.info("Mayor receiver quit of its own accord!")

    async def receive_mayor(inner_websocket):
            with open(PATH, 'wb') as fi:
                while True:
                    data = await inner_websocket.recv()
                    if not data:
                        break
                    fi.write(data)

    async def print_message_angrily(self, websocket):
        while True:
            await asyncio.sleep(ra.random() * 3)
            message = await websocket.recv()
            logging.info("{} says: Fuckin {}!".format(self.name, message))

    async def print_message_happily(self, websocket):
        while True:
            await asyncio.sleep(ra.random() * 3)
            message = await websocket.recv()
            logging.info("{} says: Love those {}!".format(self.name, message))

    async def send_message_back(self, websocket):
        while True:
            await asyncio.sleep(ra.random() * 3)
            await websocket.send("hello from {} servi!".format(self.name))

    def choose_my_function(self):
        tasks = []
        tasks.append(self.print_message_angrily)
        # tasks.append(self.print_message_happily)
        # tasks.append(self.send_message_back)
        tasks.append(self.process_mayoral_transmission)
        choice = ra.randint(0, len(tasks) - 1)
        return tasks[choice]

async def make_clients(num, address):
    towns = []
    for i in range(num):
        t = Town(address)
        towns.append(asyncio.ensure_future(t.initiate()))
    await asyncio.gather(*towns)

if __name__=="__main__":
    address = 8002
    num = 3
    asyncio.get_event_loop().run_until_complete(make_clients(num, address))
    asyncio.get_event_loop().run_forever()
from concurrent.futures import ThreadPoolExecutor
from threading import local
import time
import random as ra
import logging
import asyncio


FORMAT = "%(levelname)s@%(name)s(%(asctime)s) -- \"%(message)s\""
logging.basicConfig(level=logging.DEBUG, format=FORMAT)

class TheLandOfWhos:
    TOWNSHIPS = set([
    "Whoville",
    "Pooville",
    "Trueville",
    "Flooville",
    "Shoeville",
    "Blueville",
    "Screwville",
    "Whatatodoville",
    "Grueville",
    "Jewville",
    "Stewville",
    "Brewville",
    "Gooville",
    ])

    LOCATION_OF_THE_MAYOR_OF_WHOVILLE = "Whoville"
    TRAVELLING_STRING = "Undefined!"
    MAYOR_WHEREABOUTS_KNOWN = False

    PLACES_CHECKED = set()

    def choose_other_town(self):
        other_towns = list(self.TOWNSHIPS)
        other_towns.remove(self.LOCATION_OF_THE_MAYOR_OF_WHOVILLE)
        return other_towns[ra.randint(0, len(self.TOWNSHIPS) - 2)]

    def choose_unexamined_town(self):
        unexamined_towns = list(self.TOWNSHIPS.difference(self.PLACES_CHECKED))
        return unexamined_towns[ra.randint(0, len(unexamined_towns) - 1)]


    async def hunter_loop(self):
        while True:
            if self.MAYOR_WHEREABOUTS_KNOWN:
                await asyncio.sleep(0.1)
            else:
                await self.check_random_town()

    async def check_random_town(self):
        town = self.choose_unexamined_town()
        logging.info("Checking {}".format(town))
        self.PLACES_CHECKED.add(town)
        await asyncio.sleep((ra.random() + 0.1) * 3)
        if self.LOCATION_OF_THE_MAYOR_OF_WHOVILLE == town:
            logging.info("Found the mayor in {}!".format(town))
            self.MAYOR_WHEREABOUTS_KNOWN = True
            self.PLACES_CHECKED = set()
        elif self.LOCATION_OF_THE_MAYOR_OF_WHOVILLE == self.TRAVELLING_STRING:
            logging.info("Spies report the mayor was seen in a roadside tavern near {}!".format(town))
            self.PLACES_CHECKED = set()

    async def escapade_loop(self):
        while True:
            if self.MAYOR_WHEREABOUTS_KNOWN:
                await self.escape_to_some_other_town()
            else:
                await asyncio.sleep(0.1)

    async def escape_to_some_other_town(self):
        logging.info("The mayor escaped! Keep on the hunt!")
        destination = self.choose_other_town()
        self.LOCATION_OF_THE_MAYOR_OF_WHOVILLE = self.TRAVELLING_STRING
        self.MAYOR_WHEREABOUTS_KNOWN = False
        logging.info("Mayor is travelling to {}".format(destination))
        await asyncio.sleep(ra.randint(1, 10))
        self.LOCATION_OF_THE_MAYOR_OF_WHOVILLE = destination

    async def hunters(self):
        tasks =[]
        tasks.append(self.escapade_loop())
        tasks.append(self.hunter_loop())
        await asyncio.gather(*tasks)

if __name__=="__main__":
    l = TheLandOfWhos()
    loop = asyncio.get_event_loop().run_until_complete(l.hunters())
FROM python:3.7.2-slim

WORKDIR /usr/src/app

COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

COPY find_the_mayor_of_whoville.py ./
CMD [ "python", "./find_the_mayor_of_whoville.py"]
